# 数组

使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。
这就像你与朋友去看电影，找到地方就坐后又来了一位朋友，但原来坐的地方没有空位置，只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。如果又来了一位朋友，而当前坐的地方也没有空位，你们就得再次转移！真是太麻烦了。同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，但你应该明白，它存在如下两个缺点。
    你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。
    待办事项超过10个后，你还得转移。
因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。

假设你要为数组分配10 000个位置，内存中有10 000个位置，但不都靠在一起。在这种情况下，你将无法为该数组分配内存！
```
需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。
```

# 链表
链表中的元素可存储在内存的任何地方。
链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。

这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因
此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。

### 在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。

只要有足够的内存空间，就能为链表分配内存。
链表的优势在插入元素方面。

在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。

2.4 小结
 计算机内存犹如一大堆抽屉。
 需要存储多个元素时，可使用数组或链表。
 数组的元素都在一起。
 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
 数组的读取速度很快。
 链表的插入和删除速度很快。
 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。